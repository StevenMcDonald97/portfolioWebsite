{"ast":null,"code":"//\n// FileReader\n//\n// http://www.w3.org/TR/FileAPI/#dfn-filereader\n// https://developer.mozilla.org/en/DOM/FileReader\n(function () {\n  \"use strict\";\n\n  var fs = require(\"fs\"),\n      EventEmitter = require(\"events\").EventEmitter;\n\n  function doop(fn, args, context) {\n    if ('function' === typeof fn) {\n      fn.apply(context, args);\n    }\n  }\n\n  function toDataUrl(data, type) {\n    // var data = self.result;\n    var dataUrl = 'data:';\n\n    if (type) {\n      dataUrl += type + ';';\n    }\n\n    if (/text/i.test(type)) {\n      dataUrl += 'charset=utf-8,';\n      dataUrl += data.toString('utf8');\n    } else {\n      dataUrl += 'base64,';\n      dataUrl += data.toString('base64');\n    }\n\n    return dataUrl;\n  }\n\n  function mapDataToFormat(file, data, format, encoding) {\n    // var data = self.result;\n    switch (format) {\n      case 'buffer':\n        return data;\n        break;\n\n      case 'binary':\n        return data.toString('binary');\n        break;\n\n      case 'dataUrl':\n        return toDataUrl(data, file.type);\n        break;\n\n      case 'text':\n        return data.toString(encoding || 'utf8');\n        break;\n    }\n  }\n\n  function FileReader() {\n    var self = this,\n        emitter = new EventEmitter(),\n        file;\n\n    self.addEventListener = function (on, callback) {\n      emitter.on(on, callback);\n    };\n\n    self.removeEventListener = function (callback) {\n      emitter.removeListener(callback);\n    };\n\n    self.dispatchEvent = function (on) {\n      emitter.emit(on);\n    };\n\n    self.EMPTY = 0;\n    self.LOADING = 1;\n    self.DONE = 2;\n    self.error = undefined; // Read only\n\n    self.readyState = self.EMPTY; // Read only\n\n    self.result = undefined; // Road only\n    // non-standard\n\n    self.on = function () {\n      emitter.on.apply(emitter, arguments);\n    };\n\n    self.nodeChunkedEncoding = false;\n\n    self.setNodeChunkedEncoding = function (val) {\n      self.nodeChunkedEncoding = val;\n    }; // end non-standard\n    // Whatever the file object is, turn it into a Node.JS File.Stream\n\n\n    function createFileStream() {\n      var stream = new EventEmitter(),\n          chunked = self.nodeChunkedEncoding; // attempt to make the length computable\n\n      if (!file.size && chunked && file.path) {\n        fs.stat(file.path, function (err, stat) {\n          file.size = stat.size;\n          file.lastModifiedDate = stat.mtime;\n        });\n      } // The stream exists, do nothing more\n\n\n      if (file.stream) {\n        return;\n      } // Create a read stream from a buffer\n\n\n      if (file.buffer) {\n        process.nextTick(function () {\n          stream.emit('data', file.buffer);\n          stream.emit('end');\n        });\n        file.stream = stream;\n        return;\n      } // Create a read stream from a file\n\n\n      if (file.path) {\n        // TODO url\n        if (!chunked) {\n          fs.readFile(file.path, function (err, data) {\n            if (err) {\n              stream.emit('error', err);\n            }\n\n            if (data) {\n              stream.emit('data', data);\n              stream.emit('end');\n            }\n          });\n          file.stream = stream;\n          return;\n        } // TODO don't duplicate this code here,\n        // expose a method in File instead\n\n\n        file.stream = fs.createReadStream(file.path);\n      }\n    } // before any other listeners are added\n\n\n    emitter.on('abort', function () {\n      self.readyState = self.DONE;\n    }); // Map `error`, `progress`, `load`, and `loadend`\n\n    function mapStreamToEmitter(format, encoding) {\n      var stream = file.stream,\n          buffers = [],\n          chunked = self.nodeChunkedEncoding;\n      buffers.dataLength = 0;\n      stream.on('error', function (err) {\n        if (self.DONE === self.readyState) {\n          return;\n        }\n\n        self.readyState = self.DONE;\n        self.error = err;\n        emitter.emit('error', err);\n      });\n      stream.on('data', function (data) {\n        if (self.DONE === self.readyState) {\n          return;\n        }\n\n        buffers.dataLength += data.length;\n        buffers.push(data);\n        emitter.emit('progress', {\n          // fs.stat will probably complete before this\n          // but possibly it will not, hence the check\n          lengthComputable: !isNaN(file.size) ? true : false,\n          loaded: buffers.dataLength,\n          total: file.size\n        });\n        emitter.emit('data', data);\n      });\n      stream.on('end', function () {\n        if (self.DONE === self.readyState) {\n          return;\n        }\n\n        var data;\n\n        if (buffers.length > 1) {\n          data = Buffer.concat(buffers);\n        } else {\n          data = buffers[0];\n        }\n\n        self.readyState = self.DONE;\n        self.result = mapDataToFormat(file, data, format, encoding);\n        emitter.emit('load', {\n          target: {\n            // non-standard\n            nodeBufferResult: data,\n            result: self.result\n          }\n        });\n        emitter.emit('loadend');\n      });\n    } // Abort is overwritten by readAsXyz\n\n\n    self.abort = function () {\n      if (self.readState == self.DONE) {\n        return;\n      }\n\n      self.readyState = self.DONE;\n      emitter.emit('abort');\n    }; // \n\n\n    function mapUserEvents() {\n      emitter.on('start', function () {\n        doop(self.onloadstart, arguments);\n      });\n      emitter.on('progress', function () {\n        doop(self.onprogress, arguments);\n      });\n      emitter.on('error', function (err) {\n        // TODO translate to FileError\n        if (self.onerror) {\n          self.onerror(err);\n        } else {\n          if (!emitter.listeners.error || !emitter.listeners.error.length) {\n            throw err;\n          }\n        }\n      });\n      emitter.on('load', function () {\n        doop(self.onload, arguments);\n      });\n      emitter.on('end', function () {\n        doop(self.onloadend, arguments);\n      });\n      emitter.on('abort', function () {\n        doop(self.onabort, arguments);\n      });\n    }\n\n    function readFile(_file, format, encoding) {\n      file = _file;\n\n      if (!file || !file.name || !(file.path || file.stream || file.buffer)) {\n        throw new Error(\"cannot read as File: \" + JSON.stringify(file));\n      }\n\n      if (0 !== self.readyState) {\n        console.log(\"already loading, request to change format ignored\");\n        return;\n      } // 'process.nextTick' does not ensure order, (i.e. an fs.stat queued later may return faster)\n      // but `onloadstart` must come before the first `data` event and must be asynchronous.\n      // Hence we waste a single tick waiting\n\n\n      process.nextTick(function () {\n        self.readyState = self.LOADING;\n        emitter.emit('loadstart');\n        createFileStream();\n        mapStreamToEmitter(format, encoding);\n        mapUserEvents();\n      });\n    }\n\n    self.readAsArrayBuffer = function (file) {\n      readFile(file, 'buffer');\n    };\n\n    self.readAsBinaryString = function (file) {\n      readFile(file, 'binary');\n    };\n\n    self.readAsDataURL = function (file) {\n      readFile(file, 'dataUrl');\n    };\n\n    self.readAsText = function (file, encoding) {\n      readFile(file, 'text', encoding);\n    };\n  }\n\n  module.exports = FileReader;\n})();","map":{"version":3,"sources":["/Users/Steven/CS-Projects/portfolio-template/portfolioWebsite/node_modules/filereader/FileReader.js"],"names":["fs","require","EventEmitter","doop","fn","args","context","apply","toDataUrl","data","type","dataUrl","test","toString","mapDataToFormat","file","format","encoding","FileReader","self","emitter","addEventListener","on","callback","removeEventListener","removeListener","dispatchEvent","emit","EMPTY","LOADING","DONE","error","undefined","readyState","result","arguments","nodeChunkedEncoding","setNodeChunkedEncoding","val","createFileStream","stream","chunked","size","path","stat","err","lastModifiedDate","mtime","buffer","process","nextTick","readFile","createReadStream","mapStreamToEmitter","buffers","dataLength","length","push","lengthComputable","isNaN","loaded","total","Buffer","concat","target","nodeBufferResult","abort","readState","mapUserEvents","onloadstart","onprogress","onerror","listeners","onload","onloadend","onabort","_file","name","Error","JSON","stringify","console","log","readAsArrayBuffer","readAsBinaryString","readAsDataURL","readAsText","module","exports"],"mappings":"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","sourcesContent":["//\n// FileReader\n//\n// http://www.w3.org/TR/FileAPI/#dfn-filereader\n// https://developer.mozilla.org/en/DOM/FileReader\n(function () {\n  \"use strict\";\n\n  var fs = require(\"fs\")\n    , EventEmitter = require(\"events\").EventEmitter\n    ;\n\n  function doop(fn, args, context) {\n    if ('function' === typeof fn) {\n      fn.apply(context, args);\n    }\n  }\n\n  function toDataUrl(data, type) {\n    // var data = self.result;\n    var dataUrl = 'data:';\n\n    if (type) {\n      dataUrl += type + ';';\n    }\n\n    if (/text/i.test(type)) {\n      dataUrl += 'charset=utf-8,';\n      dataUrl += data.toString('utf8');\n    } else {\n      dataUrl += 'base64,';\n      dataUrl += data.toString('base64');\n    }\n\n    return dataUrl;\n  }\n\n  function mapDataToFormat(file, data, format, encoding) {\n    // var data = self.result;\n\n    switch(format) {\n      case 'buffer':\n        return data;\n        break;\n      case 'binary':\n        return data.toString('binary');\n        break;\n      case 'dataUrl':\n        return toDataUrl(data, file.type);\n        break;\n      case 'text':\n        return data.toString(encoding || 'utf8');\n        break;\n    }\n  }\n\n  function FileReader() {\n    var self = this,\n      emitter = new EventEmitter,\n      file;\n\n    self.addEventListener = function (on, callback) {\n      emitter.on(on, callback);\n    };\n    self.removeEventListener = function (callback) {\n      emitter.removeListener(callback);\n    }\n    self.dispatchEvent = function (on) {\n      emitter.emit(on);\n    }\n\n    self.EMPTY = 0;\n    self.LOADING = 1;\n    self.DONE = 2;\n\n    self.error = undefined;         // Read only\n    self.readyState = self.EMPTY;   // Read only\n    self.result = undefined;        // Road only\n\n    // non-standard\n    self.on = function () {\n      emitter.on.apply(emitter, arguments);\n    }\n    self.nodeChunkedEncoding = false;\n    self.setNodeChunkedEncoding = function (val) {\n      self.nodeChunkedEncoding = val;\n    };\n    // end non-standard\n\n\n\n    // Whatever the file object is, turn it into a Node.JS File.Stream\n    function createFileStream() {\n      var stream = new EventEmitter(),\n        chunked = self.nodeChunkedEncoding;\n\n      // attempt to make the length computable\n      if (!file.size && chunked && file.path) {\n        fs.stat(file.path, function (err, stat) {\n          file.size = stat.size;\n          file.lastModifiedDate = stat.mtime;\n        });\n      }\n\n\n      // The stream exists, do nothing more\n      if (file.stream) {\n        return;\n      }\n\n\n      // Create a read stream from a buffer\n      if (file.buffer) {\n        process.nextTick(function () {\n          stream.emit('data', file.buffer);\n          stream.emit('end');\n        });\n        file.stream = stream;\n        return;\n      }\n\n\n      // Create a read stream from a file\n      if (file.path) {\n        // TODO url\n        if (!chunked) {\n          fs.readFile(file.path, function (err, data) {\n            if (err) {\n              stream.emit('error', err);\n            }\n            if (data) {\n              stream.emit('data', data);\n              stream.emit('end');\n            }\n          });\n\n          file.stream = stream;\n          return;\n        }\n\n        // TODO don't duplicate this code here,\n        // expose a method in File instead\n        file.stream = fs.createReadStream(file.path);\n      }\n    }\n\n\n\n    // before any other listeners are added\n    emitter.on('abort', function () {\n      self.readyState = self.DONE;\n    });\n\n\n\n    // Map `error`, `progress`, `load`, and `loadend`\n    function mapStreamToEmitter(format, encoding) {\n      var stream = file.stream,\n        buffers = [],\n        chunked = self.nodeChunkedEncoding;\n\n      buffers.dataLength = 0;\n\n      stream.on('error', function (err) {\n        if (self.DONE === self.readyState) {\n          return;\n        }\n\n        self.readyState = self.DONE;\n        self.error = err;\n        emitter.emit('error', err);\n      });\n\n      stream.on('data', function (data) {\n        if (self.DONE === self.readyState) {\n          return;\n        }\n\n        buffers.dataLength += data.length;\n        buffers.push(data);\n\n        emitter.emit('progress', {\n          // fs.stat will probably complete before this\n          // but possibly it will not, hence the check\n          lengthComputable: (!isNaN(file.size)) ? true : false,\n          loaded: buffers.dataLength,\n          total: file.size\n        });\n\n        emitter.emit('data', data);\n      });\n\n      stream.on('end', function () {\n        if (self.DONE === self.readyState) {\n          return;\n        }\n\n        var data;\n\n        if (buffers.length > 1 ) {\n          data = Buffer.concat(buffers);\n        } else {\n          data = buffers[0];\n        }\n\n        self.readyState = self.DONE;\n        self.result = mapDataToFormat(file, data, format, encoding);\n        emitter.emit('load', {\n          target: {\n            // non-standard\n            nodeBufferResult: data,\n            result: self.result\n          }\n        });\n\n        emitter.emit('loadend');\n      });\n    }\n\n\n    // Abort is overwritten by readAsXyz\n    self.abort = function () {\n      if (self.readState == self.DONE) {\n        return;\n      }\n      self.readyState = self.DONE;\n      emitter.emit('abort');\n    };\n\n\n\n    // \n    function mapUserEvents() {\n      emitter.on('start', function () {\n        doop(self.onloadstart, arguments);\n      });\n      emitter.on('progress', function () {\n        doop(self.onprogress, arguments);\n      });\n      emitter.on('error', function (err) {\n        // TODO translate to FileError\n        if (self.onerror) {\n          self.onerror(err);\n        } else {\n          if (!emitter.listeners.error || !emitter.listeners.error.length) {\n            throw err;\n          }\n        }\n      });\n      emitter.on('load', function () {\n        doop(self.onload, arguments);\n      });\n      emitter.on('end', function () {\n        doop(self.onloadend, arguments);\n      });\n      emitter.on('abort', function () {\n        doop(self.onabort, arguments);\n      });\n    }\n\n\n\n    function readFile(_file, format, encoding) {\n      file = _file;\n      if (!file || !file.name || !(file.path || file.stream || file.buffer)) {\n        throw new Error(\"cannot read as File: \" + JSON.stringify(file));\n      }\n      if (0 !== self.readyState) {\n        console.log(\"already loading, request to change format ignored\");\n        return;\n      }\n\n      // 'process.nextTick' does not ensure order, (i.e. an fs.stat queued later may return faster)\n      // but `onloadstart` must come before the first `data` event and must be asynchronous.\n      // Hence we waste a single tick waiting\n      process.nextTick(function () {\n        self.readyState = self.LOADING;\n        emitter.emit('loadstart');\n        createFileStream();\n        mapStreamToEmitter(format, encoding);\n        mapUserEvents();\n      });\n    }\n\n    self.readAsArrayBuffer = function (file) {\n      readFile(file, 'buffer');\n    };\n    self.readAsBinaryString = function (file) {\n      readFile(file, 'binary');\n    };\n    self.readAsDataURL = function (file) {\n      readFile(file, 'dataUrl');\n    };\n    self.readAsText = function (file, encoding) {\n      readFile(file, 'text', encoding);\n    };\n  }\n\n  module.exports = FileReader;\n}());\n"]},"metadata":{},"sourceType":"script"}